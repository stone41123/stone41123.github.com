---
title: 1.19
date: 2022-1-22 00:35:40
tags:
 - 搜索
mathjax: true
---

## [A - Anti-Tetris](http://codeforces.com/problemset/problem/1578/A)

网格图搜索，直接bfs即可。

补题时挂了一发是因为忘了俄罗斯方块的隐含条件是不能向上走了，按照默认四个方向都可以走来做的。

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<iostream>
#include<algorithm>
#include<vector>
#define LL long long
using namespace std;
inline int read(){
	int x=0,f=1;char ch=' ';
	while(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0' && ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return f==1?x:-x;
}

typedef pair<int,int> pii;

const int N=55,b[4][2]={{0,1},{-1,0},{1,0},{0,-1}};
vector<int> t1[N*N];
vector<pii> t2[N*N];
int n,m,a[N][N],minx[N*N],miny[N*N],cnt,f[N*N],tot,vis[N][N],pre[N*N],dir[N*N],ans[N*N],tag[N*N];
char s[N][N],tb[5]="RUDL";
pii q[N*N];

inline void dfs(int x,int y,char c){
	//cerr<<x<<' '<<y<<' '<<c<<endl;
	a[x][y]=cnt;
	minx[cnt]=min(minx[cnt],x);
	t2[cnt].push_back(pii(x,y));
	for(int i=0;i<4;++i){
		int tx=x+b[i][0],ty=y+b[i][1];
		if(tx<1 || tx>n || ty<1 || ty>m)continue;
		if(s[tx][ty]!=c)continue;
		if(a[tx][ty])continue;
		dfs(tx,ty,c);
	}
}

inline bool bfs(int k){
	int l=1,r=1;
	q[1]=pii(minx[k],miny[k]);
	pre[1]=0;
	vis[minx[k]][miny[k]]=1;
	int id=0;
	//cerr<<k<<endl;
	while(l<=r){
		pii tmp=q[l++];
		//cerr<<tmp.first<<' '<<tmp.second<<endl;
		if(tmp.first==1){
			id=l-1;
			break;
		}
		for(int i=0;i<4;++i){
			if(i==2)continue;
			int tx=tmp.first+b[i][0],ty=tmp.second+b[i][1];
			if(tx<1 || tx>n || ty<1 || ty>m)continue;
			if(vis[tx][ty])continue;
			int flag=0;
			for(vector<pii>::iterator it=t2[k].begin();it!=t2[k].end();++it){
				int px=tx+it->first,py=ty+it->second;
				if(px<1 || px>n || py<1 || py>m){
					flag=1;
					break;
				}
				if(a[px][py]!=k && a[px][py]!=0){
					flag=1;
					break;
				}
			}
			if(flag)continue;
			vis[tx][ty]=1;
			q[++r]=pii(tx,ty);
			pre[r]=l-1;
			dir[r]=i;
		}
	}
	for(int i=1;i<=r;++i)vis[q[i].first][q[i].second]=0;
	if(!id)return 0;
	f[++tot]=k;
	tag[k]=1;
	ans[k]=q[id].second;
	while(pre[id]){
		t1[k].push_back(3-dir[id]);
		id=pre[id];
	}
	for(vector<pii>::iterator it=t2[k].begin();it!=t2[k].end();++it){
		a[minx[k]+it->first][miny[k]+it->second]=0;
	}
	return 1;
}

int main(){
	n=read();m=read();
	for(int i=1;i<=n;++i){
		scanf("%s",s[i]+1);
	}
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			if(s[i][j]=='.' || a[i][j])continue;
			++cnt;
			minx[cnt]=n;
			miny[cnt]=m;
			dfs(i,j,s[i][j]);
			for(vector<pii>::iterator it=t2[cnt].begin();it!=t2[cnt].end();++it){
				if(it->first!=minx[cnt])continue;
				miny[cnt]=min(miny[cnt],it->second);
			}
			for(vector<pii>::iterator it=t2[cnt].begin();it!=t2[cnt].end();++it){
				it->first-=minx[cnt];
				it->second-=miny[cnt];
				//cerr<<it->first<<' '<<it->second<<endl;
			}
			//cerr<<endl;
		}
	}
	int sum=0,num;
	do{
		num=0;
		for(int i=1;i<=cnt;++i){
			if(tag[i])continue;
			num+=bfs(i);
		}
		sum+=num;
	}while(num);
	if(sum<cnt){
		printf("-1\n");
		return 0;
	}
	printf("%d\n",tot);
	for(int i=tot;i>=1;--i){
		printf("%d ",ans[f[i]]);
		for(vector<int>::iterator it=t1[f[i]].begin();it!=t1[f[i]].end();++it){
			putchar(tb[*it]);
		}
		putchar('S');
		putchar('\n');
	}
	return 0;
}
```

