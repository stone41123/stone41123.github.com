---
title: 1.19
date: 2022-1-22 00:35:40
tags:
 - 搜索
 - 线段树
mathjax: true
---

## [A - Anti-Tetris](http://codeforces.com/problemset/problem/1578/A)

网格图搜索，直接bfs即可。

补题时挂了一发是因为忘了俄罗斯方块的隐含条件是不能向上走了，按照默认四个方向都可以走来做的。

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<iostream>
#include<algorithm>
#include<vector>
#define LL long long
using namespace std;
inline int read(){
	int x=0,f=1;char ch=' ';
	while(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0' && ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return f==1?x:-x;
}

typedef pair<int,int> pii;

const int N=55,b[4][2]={{0,1},{-1,0},{1,0},{0,-1}};
vector<int> t1[N*N];
vector<pii> t2[N*N];
int n,m,a[N][N],minx[N*N],miny[N*N],cnt,f[N*N],tot,vis[N][N],pre[N*N],dir[N*N],ans[N*N],tag[N*N];
char s[N][N],tb[5]="RUDL";
pii q[N*N];

inline void dfs(int x,int y,char c){
	//cerr<<x<<' '<<y<<' '<<c<<endl;
	a[x][y]=cnt;
	minx[cnt]=min(minx[cnt],x);
	t2[cnt].push_back(pii(x,y));
	for(int i=0;i<4;++i){
		int tx=x+b[i][0],ty=y+b[i][1];
		if(tx<1 || tx>n || ty<1 || ty>m)continue;
		if(s[tx][ty]!=c)continue;
		if(a[tx][ty])continue;
		dfs(tx,ty,c);
	}
}

inline bool bfs(int k){
	int l=1,r=1;
	q[1]=pii(minx[k],miny[k]);
	pre[1]=0;
	vis[minx[k]][miny[k]]=1;
	int id=0;
	//cerr<<k<<endl;
	while(l<=r){
		pii tmp=q[l++];
		//cerr<<tmp.first<<' '<<tmp.second<<endl;
		if(tmp.first==1){
			id=l-1;
			break;
		}
		for(int i=0;i<4;++i){
			if(i==2)continue;
			int tx=tmp.first+b[i][0],ty=tmp.second+b[i][1];
			if(tx<1 || tx>n || ty<1 || ty>m)continue;
			if(vis[tx][ty])continue;
			int flag=0;
			for(vector<pii>::iterator it=t2[k].begin();it!=t2[k].end();++it){
				int px=tx+it->first,py=ty+it->second;
				if(px<1 || px>n || py<1 || py>m){
					flag=1;
					break;
				}
				if(a[px][py]!=k && a[px][py]!=0){
					flag=1;
					break;
				}
			}
			if(flag)continue;
			vis[tx][ty]=1;
			q[++r]=pii(tx,ty);
			pre[r]=l-1;
			dir[r]=i;
		}
	}
	for(int i=1;i<=r;++i)vis[q[i].first][q[i].second]=0;
	if(!id)return 0;
	f[++tot]=k;
	tag[k]=1;
	ans[k]=q[id].second;
	while(pre[id]){
		t1[k].push_back(3-dir[id]);
		id=pre[id];
	}
	for(vector<pii>::iterator it=t2[k].begin();it!=t2[k].end();++it){
		a[minx[k]+it->first][miny[k]+it->second]=0;
	}
	return 1;
}

int main(){
	n=read();m=read();
	for(int i=1;i<=n;++i){
		scanf("%s",s[i]+1);
	}
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			if(s[i][j]=='.' || a[i][j])continue;
			++cnt;
			minx[cnt]=n;
			miny[cnt]=m;
			dfs(i,j,s[i][j]);
			for(vector<pii>::iterator it=t2[cnt].begin();it!=t2[cnt].end();++it){
				if(it->first!=minx[cnt])continue;
				miny[cnt]=min(miny[cnt],it->second);
			}
			for(vector<pii>::iterator it=t2[cnt].begin();it!=t2[cnt].end();++it){
				it->first-=minx[cnt];
				it->second-=miny[cnt];
				//cerr<<it->first<<' '<<it->second<<endl;
			}
			//cerr<<endl;
		}
	}
	int sum=0,num;
	do{
		num=0;
		for(int i=1;i<=cnt;++i){
			if(tag[i])continue;
			num+=bfs(i);
		}
		sum+=num;
	}while(num);
	if(sum<cnt){
		printf("-1\n");
		return 0;
	}
	printf("%d\n",tot);
	for(int i=tot;i>=1;--i){
		printf("%d ",ans[f[i]]);
		for(vector<int>::iterator it=t1[f[i]].begin();it!=t1[f[i]].end();++it){
			putchar(tb[*it]);
		}
		putchar('S');
		putchar('\n');
	}
	return 0;
}
```

## [B - Building Forest Trails](https://codeforces.com/problemset/problem/1578/B)

其实就是用线段树维护一种暴力

首先我们注意到同一连通块内连边方式并不重要，这里可以反证法：

如果连边方式对答案有影响，那么一定存在两个点要连边时穿过了该连通块，并且没有直接与连通块的边相交，此时会发现连通块被分成了两半，产生了矛盾，则假设错误，连边方式对答案没有影响。

那么这里我们可以钦定一种便于我们使用的连边方式，就是顺次连边并且不连穿过 $(n,1)$ 的那条边，比如有 $1,3,5$ 三个点，那么就连两条边： $(1,3),\ (3,5)$ 。

我们建立一个虚拟节点，该节点位于 $(n,1)$ 之间，我们定义一个点的深度为从虚拟节点到该节点连边会**穿过**的边的条数，例如有四条边：

$ (1,3),\ (3,7),\ (7,9),\ (4,6) $ ，那么这时深度为 2 的点只有 5 ，深度为 1 的点有 2,4,6,8 。

在这种定义之下，我们考虑如何加边 & 合并，这里假设要加的边为 $(x,y)$ 。同时我们约定一些定义：$L(x)$ 代表 $x$ 所在连通块中下标最小的点， $R(x)$ 代表 $x$ 所在连通块中下标最大的点。

1. 如果 $x$ 和 $y$ 在同一个连通块中，那么不需要做任何操作。
2. 如果 $x$ 和 $y$ 所在连通块不同，且深度也不同，那么我们发现深度较大的那个点所在连通块必然会被一条边包围，此时需要进行一次合并。我们找到与该点相邻最近的深度小于该点的点（这里我们可以钦定所求点下标在该点之后，不影响结果），即为需要参与合并的边的一个端点。然后进行合并，发现进行合并时只需要进行一次区间减法。
3. 如果 $x$ 和 $y$ 所在连通块不同，且深度相同，那么此时存在两种情况：一种是 $x$ 和 $y$ 之间没有任何阻隔了，可以直接合并然后结束；另一种是 $x$ 和 $y$ 之间还存在阻隔，那么任意合并其中某一侧即可。如何判断是哪种情况呢？我们只需要再次找到与该点相邻最近的深度小于该点的点（钦定下标在该点之后），如果找到的这个点 $z$ 在 $(x,y)$ 之间，并且 $L(z)<x$ ，那么此时就存在阻隔，否则不存在。

我们重复判断是否符合 2,3 中的一种情况，并且执行对应情况的对策，最终就会完成合并。

这看起来非常像一个暴力，不过我们可以来分析一下复杂度如何。

你发现合并时每进行一轮，就会有一次合并发生，最多每两次合并就会减少一个连通块。

初始时有 $n$ 个连通块，并且没有任何操作会使连通块的数量减少，再加上用线段树来维护上述两种操作，均摊时间复杂度即为 $O(nlogn)$ ，需要注意的一点是线段树上二分寻找答案时，找到答案需要立即退出，不然复杂度就没有保证了。

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<iostream>
#include<algorithm>
#include<ctime>
#define LL long long
using namespace std;
inline int read(){
	int x=0,f=1;char ch=' ';
	while(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0' && ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return f==1?x:-x;
}

const int N=3e5+5;

int mn[N<<2],cg[N<<2];
inline void pushdown(int rt){
	if(cg[rt]){
		cg[rt<<1]+=cg[rt];
		cg[rt<<1|1]+=cg[rt];
		mn[rt<<1]+=cg[rt];
		mn[rt<<1|1]+=cg[rt];
		cg[rt]=0;
	}
}
inline void modify(int rt,int l,int r,int L,int R,int v){
	if(L>R)return;
	if(L<=l && r<=R){
		mn[rt]+=v;
		cg[rt]+=v;
		return;
	}
	pushdown(rt);
	int mid=(l+r)>>1;
	if(L<=mid)modify(rt<<1,l,mid,L,R,v);
	if(mid<R)modify(rt<<1|1,mid+1,r,L,R,v);
	mn[rt]=min(mn[rt<<1],mn[rt<<1|1]);
}
inline int query(int rt,int l,int r,int pos){
	if(l==r)return mn[rt];
	pushdown(rt);
	int mid=(l+r)>>1;
	if(pos<=mid)return query(rt<<1,l,mid,pos);
	else return query(rt<<1|1,mid+1,r,pos);
}
int flag,ans;
inline void querymn(int rt,int l,int r,int pos,int val){
	if(l==r){
		if(mn[rt]<val){
			flag=1;
			ans=l;
		}
		return;
	}
	pushdown(rt);
	int mid=(l+r)>>1;
	if(pos<mid && mn[rt<<1]<val)querymn(rt<<1,l,mid,pos,val);
	if(flag || mn[rt<<1|1]>=val)return;
	querymn(rt<<1|1,mid+1,r,pos,val);
}

int n,m,f[N],L[N],R[N],pre[N];
inline int find(int x){return f[x]==x?x:f[x]=find(f[x]);}

int merge_cnt;

inline void merge(int x,int y){
	merge_cnt++;
	int u=find(x),v=find(y);
	modify(1,1,n,L[u],R[u],-1);
	pre[L[u]]=pre[y];
	pre[y]=R[u];
	f[u]=v;
}

int main(){
	//int tm=clock();
	n=read();m=read();
	for(int i=1;i<=n;++i)f[i]=pre[i]=L[i]=R[i]=i;
	while(m--){
		int opt=read(),x=read(),y=read();
		if(x>y)swap(x,y);
		if(opt==1){
			if(find(x)==find(y))continue;
			int dx=query(1,1,n,x),dy=query(1,1,n,y);
			while(1){
				if(dx>dy){
					flag=0;
					querymn(1,1,n,x,dx);
					merge(x,ans);
					dx--;
				}
				else if(dx<dy){
					flag=0;
					querymn(1,1,n,y,dy);
					merge(y,ans);
					dy--;
				}
				else{
					flag=0;
					querymn(1,1,n,x,dx);
					if(flag && ans<L[find(y)] && L[find(ans)]<x){
						merge(x,ans);
						dx--;
					}
					else{
						int u=find(x),v=find(y);
						pre[L[v]]=R[u];
						modify(1,1,n,R[u]+1,L[v]-1,1);
						f[v]=u;
						R[u]=R[v];
						break;
					}
				}
			}
		}
		else{
			if(find(x)==find(y))putchar('1');
			else putchar('0');
		}
	}
	//cerr<<clock()-tm<<endl;
	//cerr<<merge_cnt<<endl;
	return 0;
}
```

