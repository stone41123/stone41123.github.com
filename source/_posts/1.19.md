---
title: 1.19
date: 2022-1-22 00:35:40
tags:
 - 搜索
 - 线段树
 - 计算几何
mathjax: true
---

## [A - Anti-Tetris](http://codeforces.com/problemset/problem/1578/A)

网格图搜索，直接bfs即可。

补题时挂了一发是因为忘了俄罗斯方块的隐含条件是不能向上走了，按照默认四个方向都可以走来做的。

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<iostream>
#include<algorithm>
#include<vector>
#define LL long long
using namespace std;
inline int read(){
	int x=0,f=1;char ch=' ';
	while(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0' && ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return f==1?x:-x;
}

typedef pair<int,int> pii;

const int N=55,b[4][2]={{0,1},{-1,0},{1,0},{0,-1}};
vector<int> t1[N*N];
vector<pii> t2[N*N];
int n,m,a[N][N],minx[N*N],miny[N*N],cnt,f[N*N],tot,vis[N][N],pre[N*N],dir[N*N],ans[N*N],tag[N*N];
char s[N][N],tb[5]="RUDL";
pii q[N*N];

inline void dfs(int x,int y,char c){
	//cerr<<x<<' '<<y<<' '<<c<<endl;
	a[x][y]=cnt;
	minx[cnt]=min(minx[cnt],x);
	t2[cnt].push_back(pii(x,y));
	for(int i=0;i<4;++i){
		int tx=x+b[i][0],ty=y+b[i][1];
		if(tx<1 || tx>n || ty<1 || ty>m)continue;
		if(s[tx][ty]!=c)continue;
		if(a[tx][ty])continue;
		dfs(tx,ty,c);
	}
}

inline bool bfs(int k){
	int l=1,r=1;
	q[1]=pii(minx[k],miny[k]);
	pre[1]=0;
	vis[minx[k]][miny[k]]=1;
	int id=0;
	//cerr<<k<<endl;
	while(l<=r){
		pii tmp=q[l++];
		//cerr<<tmp.first<<' '<<tmp.second<<endl;
		if(tmp.first==1){
			id=l-1;
			break;
		}
		for(int i=0;i<4;++i){
			if(i==2)continue;
			int tx=tmp.first+b[i][0],ty=tmp.second+b[i][1];
			if(tx<1 || tx>n || ty<1 || ty>m)continue;
			if(vis[tx][ty])continue;
			int flag=0;
			for(vector<pii>::iterator it=t2[k].begin();it!=t2[k].end();++it){
				int px=tx+it->first,py=ty+it->second;
				if(px<1 || px>n || py<1 || py>m){
					flag=1;
					break;
				}
				if(a[px][py]!=k && a[px][py]!=0){
					flag=1;
					break;
				}
			}
			if(flag)continue;
			vis[tx][ty]=1;
			q[++r]=pii(tx,ty);
			pre[r]=l-1;
			dir[r]=i;
		}
	}
	for(int i=1;i<=r;++i)vis[q[i].first][q[i].second]=0;
	if(!id)return 0;
	f[++tot]=k;
	tag[k]=1;
	ans[k]=q[id].second;
	while(pre[id]){
		t1[k].push_back(3-dir[id]);
		id=pre[id];
	}
	for(vector<pii>::iterator it=t2[k].begin();it!=t2[k].end();++it){
		a[minx[k]+it->first][miny[k]+it->second]=0;
	}
	return 1;
}

int main(){
	n=read();m=read();
	for(int i=1;i<=n;++i){
		scanf("%s",s[i]+1);
	}
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			if(s[i][j]=='.' || a[i][j])continue;
			++cnt;
			minx[cnt]=n;
			miny[cnt]=m;
			dfs(i,j,s[i][j]);
			for(vector<pii>::iterator it=t2[cnt].begin();it!=t2[cnt].end();++it){
				if(it->first!=minx[cnt])continue;
				miny[cnt]=min(miny[cnt],it->second);
			}
			for(vector<pii>::iterator it=t2[cnt].begin();it!=t2[cnt].end();++it){
				it->first-=minx[cnt];
				it->second-=miny[cnt];
				//cerr<<it->first<<' '<<it->second<<endl;
			}
			//cerr<<endl;
		}
	}
	int sum=0,num;
	do{
		num=0;
		for(int i=1;i<=cnt;++i){
			if(tag[i])continue;
			num+=bfs(i);
		}
		sum+=num;
	}while(num);
	if(sum<cnt){
		printf("-1\n");
		return 0;
	}
	printf("%d\n",tot);
	for(int i=tot;i>=1;--i){
		printf("%d ",ans[f[i]]);
		for(vector<int>::iterator it=t1[f[i]].begin();it!=t1[f[i]].end();++it){
			putchar(tb[*it]);
		}
		putchar('S');
		putchar('\n');
	}
	return 0;
}
```

## [B - Building Forest Trails](https://codeforces.com/problemset/problem/1578/B)

其实就是用线段树维护一种暴力

首先我们注意到同一连通块内连边方式并不重要，这里可以反证法：

如果连边方式对答案有影响，那么一定存在两个点要连边时穿过了该连通块，并且没有直接与连通块的边相交，此时会发现连通块被分成了两半，产生了矛盾，则假设错误，连边方式对答案没有影响。

那么这里我们可以钦定一种便于我们使用的连边方式，就是顺次连边并且不连穿过 $(n,1)$ 的那条边，比如有 $1,3,5$ 三个点，那么就连两条边： $(1,3),\ (3,5)$ 。

我们建立一个虚拟节点，该节点位于 $(n,1)$ 之间，我们定义一个点的深度为从虚拟节点到该节点连边会**穿过**的边的条数，例如有四条边：

$ (1,3),\ (3,7),\ (7,9),\ (4,6) $ ，那么这时深度为 2 的点只有 5 ，深度为 1 的点有 2,4,6,8 。

在这种定义之下，我们考虑如何加边 & 合并，这里假设要加的边为 $(x,y)$ 。同时我们约定一些定义：$L(x)$ 代表 $x$ 所在连通块中下标最小的点， $R(x)$ 代表 $x$ 所在连通块中下标最大的点。

1. 如果 $x$ 和 $y$ 在同一个连通块中，那么不需要做任何操作。
2. 如果 $x$ 和 $y$ 所在连通块不同，且深度也不同，那么我们发现深度较大的那个点所在连通块必然会被一条边包围，此时需要进行一次合并。我们找到与该点相邻最近的深度小于该点的点（这里我们可以钦定所求点下标在该点之后，不影响结果），即为需要参与合并的边的一个端点。然后进行合并，发现进行合并时只需要进行一次区间减法。
3. 如果 $x$ 和 $y$ 所在连通块不同，且深度相同，那么此时存在两种情况：一种是 $x$ 和 $y$ 之间没有任何阻隔了，可以直接合并然后结束；另一种是 $x$ 和 $y$ 之间还存在阻隔，那么任意合并其中某一侧即可。如何判断是哪种情况呢？我们只需要再次找到与该点相邻最近的深度小于该点的点（钦定下标在该点之后），如果找到的这个点 $z$ 在 $(x,y)$ 之间，并且 $L(z)<x$ ，那么此时就存在阻隔，否则不存在。

我们重复判断是否符合 2,3 中的一种情况，并且执行对应情况的对策，最终就会完成合并。

这看起来非常像一个暴力，不过我们可以来分析一下复杂度如何。

你发现合并时每进行一轮，就会有一次合并发生，最多每两次合并就会减少一个连通块。

初始时有 $n$ 个连通块，并且没有任何操作会使连通块的数量减少，再加上用线段树来维护上述两种操作，均摊时间复杂度即为 $O(nlogn)$ ，需要注意的一点是线段树上二分寻找答案时，找到答案需要立即退出，不然复杂度就没有保证了。

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<iostream>
#include<algorithm>
#include<ctime>
#define LL long long
using namespace std;
inline int read(){
	int x=0,f=1;char ch=' ';
	while(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0' && ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return f==1?x:-x;
}

const int N=3e5+5;

int mn[N<<2],cg[N<<2];
inline void pushdown(int rt){
	if(cg[rt]){
		cg[rt<<1]+=cg[rt];
		cg[rt<<1|1]+=cg[rt];
		mn[rt<<1]+=cg[rt];
		mn[rt<<1|1]+=cg[rt];
		cg[rt]=0;
	}
}
inline void modify(int rt,int l,int r,int L,int R,int v){
	if(L>R)return;
	if(L<=l && r<=R){
		mn[rt]+=v;
		cg[rt]+=v;
		return;
	}
	pushdown(rt);
	int mid=(l+r)>>1;
	if(L<=mid)modify(rt<<1,l,mid,L,R,v);
	if(mid<R)modify(rt<<1|1,mid+1,r,L,R,v);
	mn[rt]=min(mn[rt<<1],mn[rt<<1|1]);
}
inline int query(int rt,int l,int r,int pos){
	if(l==r)return mn[rt];
	pushdown(rt);
	int mid=(l+r)>>1;
	if(pos<=mid)return query(rt<<1,l,mid,pos);
	else return query(rt<<1|1,mid+1,r,pos);
}
int flag,ans;
inline void querymn(int rt,int l,int r,int pos,int val){
	if(l==r){
		if(mn[rt]<val){
			flag=1;
			ans=l;
		}
		return;
	}
	pushdown(rt);
	int mid=(l+r)>>1;
	if(pos<mid && mn[rt<<1]<val)querymn(rt<<1,l,mid,pos,val);
	if(flag || mn[rt<<1|1]>=val)return;
	querymn(rt<<1|1,mid+1,r,pos,val);
}

int n,m,f[N],L[N],R[N],pre[N];
inline int find(int x){return f[x]==x?x:f[x]=find(f[x]);}

int merge_cnt;

inline void merge(int x,int y){
	merge_cnt++;
	int u=find(x),v=find(y);
	modify(1,1,n,L[u],R[u],-1);
	pre[L[u]]=pre[y];
	pre[y]=R[u];
	f[u]=v;
}

int main(){
	//int tm=clock();
	n=read();m=read();
	for(int i=1;i<=n;++i)f[i]=pre[i]=L[i]=R[i]=i;
	while(m--){
		int opt=read(),x=read(),y=read();
		if(x>y)swap(x,y);
		if(opt==1){
			if(find(x)==find(y))continue;
			int dx=query(1,1,n,x),dy=query(1,1,n,y);
			while(1){
				if(dx>dy){
					flag=0;
					querymn(1,1,n,x,dx);
					merge(x,ans);
					dx--;
				}
				else if(dx<dy){
					flag=0;
					querymn(1,1,n,y,dy);
					merge(y,ans);
					dy--;
				}
				else{
					flag=0;
					querymn(1,1,n,x,dx);
					if(flag && ans<L[find(y)] && L[find(ans)]<x){
						merge(x,ans);
						dx--;
					}
					else{
						int u=find(x),v=find(y);
						pre[L[v]]=R[u];
						modify(1,1,n,R[u]+1,L[v]-1,1);
						f[v]=u;
						R[u]=R[v];
						break;
					}
				}
			}
		}
		else{
			if(find(x)==find(y))putchar('1');
			else putchar('0');
		}
	}
	//cerr<<clock()-tm<<endl;
	//cerr<<merge_cnt<<endl;
	return 0;
}
```



## [I - Interactive Rays](https://vjudge.net/problem/CodeForces-1578I)



计算几何。

总体思路：找到三条切线，用三条切线计算答案。

细节：询问只能询问整点，将要询问的角度转化成点值后取整，再用整点更新询问角度。

实现步骤:

1.询问坐标轴四个方向，记录所得最大值与最小值(记为fmax和fmin)及其角度(amax和amin)。

2.在1中两个角度间询问，保存结果在$(0,fmax)$间的部分，只有这部分询问有效。询问采用二分寻找某个询问结果（询问结果在这个区间内有单调性），因为二分最后步长过小导致精度问题，将最后20次询问用于以一定步长在二分得到的小区间处上下扩展来获得更多有效询问。

3.将询问排序，将角度过近的询问删去。

4.先取出前三个询问，每个询问相当于给出了圆的一条切线，这条线是距询问射线距离等于询问结果的一条直线，且与amin对应射线位于询问射线的同一方向。三条直线围成一个三角形，从而答案一定是这个三角形的内切圆以及旁切圆之一。

5.用剩下的询问check这四个圆，比较这四个圆对答案的误差，选出答案。另一个好的方法是计算这个圆的x,y,r值到最近整数的距离，距离过大的点大概率不是整点，可以舍去。



```cpp
#include<bits/stdc++.h>
#define rep(l,r) for(int i=l;i<=r;i++)
#define rrep(r,l) for(int i=r;i>=l;i--)
#define jrep(l,r) for(int j=l;j<=r;j++)
#define rjrep(r,l) for(int j=r;j>=l;j--)
#define x first
#define y second
#define drep(l,r,t) for(int i=l;i<=r;i+=t)
#define mclear(t) memset(t,0,sizeof t)
#define pb push_back
#define double long double

using namespace std;

typedef pair<double,double> PDD;
typedef long long ll;
typedef pair<int,int> PII;

template<class T>void read(T &x)
{
    x=0;int f=0;char ch=getchar();
    while(ch<'0'||ch>'9'){f|=(ch=='-');ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
    x=f?-x:x;
    return;
}

const double pi=acos(-1),eps=1e-8;
const int K=1e6,P=1e5;

int sign(double x,double y)
{
	if(fabs(x-y)<eps)return 0;
	if(x<y)return -1;
	return x>y;
}

struct Query
{
	double ang,ans;
	void query()
	{
		int x=round(K*cos(ang)),y=round(K*sin(ang));
		ang=atan2(y,x);
		if(sign(ang,0)<0)ang+=pi*2;
		printf("? %d %d\n",x,y);
		fflush(stdout);
		scanf("%Lf",&ans);
	}
	bool operator<(const Query&t)const
	{
		return ang<t.ang;
	}
	bool operator==(const Query&t)const
	{
		return fabs(ang-t.ang)<1e-6;
	}
}q[100];

struct Line
{
	double a,b,c;
	double ang()
	{
		return atan2(a,-b);
	}
};

struct Circle
{
	double x,y,r;
}cir[4];

int idx;
double Fmax,Fmin;
double amax,amin;
vector<Query> useful;
vector<Line> tang;

double Ep(double x)
{
	double u=round(x);
	return fabs(x-round(x));
}

Line get(Query t)
{
	double px=round(cos(amin)*K),py=round(sin(amin)*K);
	double x=cos(t.ang)*K,y=sin(t.ang)*K;
	double c=t.ans*sqrt(x*x+y*y)*sign(x*py,px*y);
	return {y,-x,c};
}

double dist(PDD a,PDD b)
{
	double dx=a.x-b.x,dy=a.y-b.y;
	return sqrt(dx*dx+dy*dy);
}

PDD getpt(Line A,Line B)
{
	double a1=A.a,b1=A.b,c1=A.c;
	double a2=B.a,b2=B.b,c2=B.c;
	double y=(c1*a2-c2*a1)/(b2*a1-b1*a2);
	double x=-(b1*y+c1)/a1;
	return {x,y};
}

Circle work()
{
	static int cnt[4];
//	rep(0,2)tang[i].out();
	PDD p1=getpt(tang[0],tang[1]),p2=getpt(tang[1],tang[2]),p3=getpt(tang[0],tang[2]);
	double a=dist(p2,p3),b=dist(p1,p3),c=dist(p1,p2);
	{
		double x=(a*p1.x+b*p2.x+c*p3.x)/(a+b+c),y=(a*p1.y+b*p2.y+c*p3.y)/(a+b+c);
		double r=fabs(tang[0].a*x+tang[0].b*y+tang[0].c)/sqrt(tang[0].a*tang[0].a+tang[0].b*tang[0].b);
		cir[0]={x,y,r};
	}
	{
		double x=(-a*p1.x+b*p2.x+c*p3.x)/(-a+b+c),y=(-a*p1.y+b*p2.y+c*p3.y)/(-a+b+c);
		double r=fabs(tang[0].a*x+tang[0].b*y+tang[0].c)/sqrt(tang[0].a*tang[0].a+tang[0].b*tang[0].b);
		cir[1]={x,y,r};
	}
	{
		double x=(a*p1.x-b*p2.x+c*p3.x)/(a-b+c),y=(a*p1.y-b*p2.y+c*p3.y)/(a-b+c);
		double r=fabs(tang[0].a*x+tang[0].b*y+tang[0].c)/sqrt(tang[0].a*tang[0].a+tang[0].b*tang[0].b);
		cir[2]={x,y,r};
	}
	{
		double x=(a*p1.x+b*p2.x-c*p3.x)/(a+b-c),y=(a*p1.y+b*p2.y-c*p3.y)/(a+b-c);
		double r=fabs(tang[0].a*x+tang[0].b*y+tang[0].c)/sqrt(tang[0].a*tang[0].a+tang[0].b*tang[0].b);
		cir[3]={x,y,r};
	}
	memset(cnt,0,sizeof cnt);
	jrep(3,useful.size()-1)
	{
		auto t=useful[j];
		double X=round(cos(t.ang)*K),Y=round(sin(t.ang)*K);
		int mid=-1;
		double ep=1e9;
		rep(0,3)
		{
			double x=cir[i].x,y=cir[i].y,r=cir[i].r;
			double d=fabs(Y*x-X*y)/sqrt(X*X+Y*Y);
			double epp=fabs(d-r-t.ans);
//			printf("??%Lf %Lf %Lf %Lf %Lf %Lf\n",x,y,r,d,d-r,epp);
			if(epp<1e-6)
			{
				mid=i;
				break;
			}
			if(Ep(cir[i].r)+Ep(cir[i].x)+Ep(cir[i].y)<ep)
			{
				ep=Ep(cir[i].r)+Ep(cir[i].x)+Ep(cir[i].y);
				mid=i;
			}
		}
		cnt[mid]++;
	}
	int mm=0,mid=-1;
	rep(0,3)if(cnt[i]>mm)
	{
		mid=i;
		mm=cnt[i];
	}
	return cir[mid];
}

Circle solve()
{
	useful.clear(),tang.clear();
	q[1].ang=0,q[2].ang=pi*0.5,q[3].ang=pi,q[4].ang=pi*1.5;
	rep(1,4)q[i].query();
	rep(1,4)if(sign(q[i].ang,0)<0)q[i].ang+=2*pi;
	Fmin=1e9,Fmax=-1;
	idx=4;
	rep(1,4)
	{
		if(q[i].ans<Fmin)
		{
			Fmin=q[i].ans;
			amin=q[i].ang;
		}
		if(q[i].ans>Fmax)
		{
			Fmax=q[i].ans;
			amax=q[i].ang;
		}
	}
	double l=amax,r=amin;
	if(l>r)swap(l,r);
	if(!sign(l,0)&&!sign(r,pi*1.5))l=1.5*pi,r=2*pi;
	int idl=(int)(l*2/pi+0.5)%4+1,idr=(int)(r*2/pi+0.5)%4+1;
	double ll=q[idl].ans,rr=q[idr].ans,tg=(ll+rr)/2;
	while(r-l>1e-7)
	{
		if(idx>=40)break;
		double mid=(l+r)/2;
		q[++idx].ang=mid;
		q[idx].query();
		mid=q[idx].ang;
		if(sign(q[idx].ans,0)>0&&sign(q[idx].ans,Fmax)<0)useful.pb(q[idx]);
		if(ll<rr)
		{
			if(sign(q[idx].ans,tg)>=0)r=mid;
			else l=mid;
		}
		else
		{
			if(sign(q[idx].ans,tg)>=0)l=mid;
			else r=mid;
		}
	}
	double stp=1e-4;
	while(idx<58)
	{
		l+=stp;
		q[++idx].ang=l;
		q[idx].query();
		if(sign(q[idx].ans,0)>0&&sign(q[idx].ans,Fmax)<0)useful.pb(q[idx]);
		r-=stp;
		q[++idx].ang=r;
		q[idx].query();
		if(sign(q[idx].ans,0)>0&&sign(q[idx].ans,Fmax)<0)useful.pb(q[idx]);
	}
	sort(useful.begin(),useful.end());
	useful.resize(unique(useful.begin(),useful.end())-useful.begin());
	rep(0,2)tang.pb(get(useful[i]));
	return work();
}

int main()
{
	Circle t=solve();
	printf("! %d %d %d\n",(int)round(t.x),(int)round(t.y),(int)round(t.r));
	fflush(stdout);	
	return 0;
}
```

